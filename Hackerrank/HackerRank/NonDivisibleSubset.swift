//
//  NonDivisibleSubset.swift
//  Hackerrank
//
//  Created by Sebastian Tleye on 07/03/2024.
//

import Foundation

//https://www.hackerrank.com/challenges/non-divisible-subset/problem

struct NonDivisibleSubset {

    func solve() {
        print(nonDivisibleSubset(k: 5, s: [19, 10, 12, 10, 24, 25, 22]))
        print(nonDivisibleSubset(k: 3, s: [1, 7, 2, 4]))
        print(nonDivisibleSubset(k: 7, s: [278, 576, 496, 727, 410, 124, 338, 149, 209, 702, 282, 718, 771, 575, 436]))
        print(nonDivisibleSubset(k: 4, s: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
        
//        let numbers = [
//            61197933, 56459859, 319018589, 271720536, 358582070, 849720202, 481165658,
//            675266245, 541667092, 615618805, 129027583, 755570852, 437001718, 86763458,
//            791564527, 163795318, 981341013, 516958303, 592324531, 611671866, 157795445,
//            718701842, 773810960, 72800260, 281252802, 404319361, 757224413, 682600363,
//            606641861, 986674925, 176725535, 256166138, 827035972, 124896145, 37969090,
//            136814243, 274957936, 980688849, 293456190, 141209943, 346065260, 550594766,
//            132159011, 491368651, 3772767, 131852400, 633124868, 148168785, 339205816,
//            705527969, 551343090, 824338597, 241776176, 286091680, 919941899, 728704934,
//            37548669, 513249437, 888944501, 239457900, 977532594, 140391002, 260004333,
//            911069927, 586821751, 113740158, 370372870, 97014913, 28011421, 489017248,
//            492953261, 73530695, 27277034, 570013262, 81306939, 519086053, 993680429,
//            599609256, 639477062, 677313848, 950497430, 672417749, 266140123, 601572332,
//            273157042, 777834449, 123586826
//        ]
//
//        print(nonDivisibleSubset(k: 9, s: numbers))
    }

    func nonDivisibleSubset(k: Int, s: [Int]) -> Int {
        var res = 0
        var remainders: [Int] = Array(repeating: 0, count: k)
        for j in 0..<s.count {
            remainders[s[j] % k] += 1
        }

        for i in 0..<Int(ceil(Double(k) / 2.0)) {
            if i == 0 {
                if remainders[i] > 0 {
                    res += 1
                }
            } else {
                res += max(remainders[i], remainders[k-i])
            }
        }
        
        if k % 2 == 0 {
            if remainders[k/2] > 0 { //
                res += 1
            }
        }
        
        return res
    }

}
